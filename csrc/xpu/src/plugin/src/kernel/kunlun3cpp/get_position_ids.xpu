#include "xpu/kernel/cluster.h"
#include "xpu/kernel/cluster_partition.h"
#include "xpu/kernel/cluster_primitive.h"

namespace xpu3 {
namespace plugin {

__global__ void get_position_ids(const int *seq_lens_encoder,
                                 const int *seq_lens_decoder,
                                 const int *seq_lens_this_time,
                                 int *position_ids,
                                 const int bs) {
  int cid = core_id();
  int ncores = core_num();
  int clusterid = cluster_id();
  int nclusters = cluster_num();
  int tid = clusterid * ncores + cid;


  int buf_len = 256;
  __simd__ int seq_lens_encoder_lm[buf_len];
  __simd__ int seq_lens_decoder_lm[buf_len];
  __simd__ int seq_lens_this_time_lm[buf_len];
  __simd__ int position_ids_lm[buf_len];

  GM2LM_ASYNC(seq_lens_encoder, seq_lens_encoder_lm, bs * sizeof(int));
  GM2LM_ASYNC(seq_lens_decoder, seq_lens_decoder_lm, bs * sizeof(int));
  GM2LM(seq_lens_this_time, seq_lens_this_time_lm, bs * sizeof(int));
  int encode_sum = 0;
  int is_encode = 0;
  for (int i = 0; i < bs; i++) {
    if (seq_lens_encoder_lm[i] > 0) {
      encode_sum = encode_sum + seq_lens_encoder_lm[i];
    }
  }
  for (int ind = tid; ind < bs; ind += ncores * nclusters) {
    int decode_offset = encode_sum;
    int encode_offset = 0;
    for (int i = 0; i < ind; i++) {
      if (seq_lens_encoder_lm[i] > 0) {
        encode_offset += seq_lens_encoder_lm[i];
      } else {
        decode_offset += seq_lens_this_time_lm[i];
      }
    }
    int encoder_len = seq_lens_encoder_lm[ind];
    int decoder_len = seq_lens_decoder_lm[ind];
    int seq_len_this_time = decoder_len > 0 ? seq_lens_this_time_lm[ind] : 0;
    int offset = decoder_len > 0 ? decode_offset : encode_offset;

    for (int i = 0; i < encoder_len + seq_len_this_time; i += buf_len) {
      int read_len = min(encoder_len + seq_len_this_time - i, buf_len);
      for (int j = 0; j < buf_len; j++) {
        int ind_id = i + j;
        if (ind_id < encoder_len) {
          position_ids_lm[j] = ind_id;
        } else {
          position_ids_lm[j] = decoder_len + ind_id;
        }
      }
      LM2GM(position_ids_lm, position_ids + offset + i, read_len * sizeof(int));
    }
  }
}

}  // namespace plugin
}  // namespace xpu3
